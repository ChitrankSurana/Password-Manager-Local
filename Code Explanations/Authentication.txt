AUTHENTICATION SYSTEM - DETAILED CODE EXPLANATION
================================================

This document provides a comprehensive explanation of the authentication system
implementation for the Personal Password Manager, covering session management,
security features, and user workflows.

OVERVIEW:
---------
The authentication system (src/core/auth.py) provides secure user authentication
and session management services. It acts as a bridge between the database and
encryption systems, offering a high-level interface for user operations with
comprehensive security features.

KEY COMPONENTS:
--------------

1. AUTHENTICATION MANAGER CLASS:
   - Central authentication service
   - Session lifecycle management
   - User account operations
   - Security policy enforcement
   - Background session cleanup

2. USER SESSION CLASS:
   - Session data structure
   - Security metadata tracking
   - Activity monitoring
   - Expiration management

3. SECURITY FEATURES:
   - Cryptographically secure session tokens
   - Automatic session expiration
   - Concurrent session limits
   - Account lockout integration
   - Security event logging

AUTHENTICATION ARCHITECTURE:
---------------------------

SYSTEM INTEGRATION:
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   GUI / Web     │───▶│  Authentication │───▶│    Database     │
│   Interface     │    │     Manager     │    │    Manager      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                              │
                              ▼
                       ┌─────────────────┐
                       │   Encryption    │
                       │     System      │
                       └─────────────────┘

AUTHENTICATION FLOW:
1. User provides credentials (username/password)
2. Authentication Manager validates with Database Manager
3. Database Manager checks user credentials and lockout status
4. On success, Authentication Manager creates secure session
5. Session token returned to client for future operations
6. All operations require valid session token
7. Sessions automatically expire or can be explicitly logged out

SESSION MANAGEMENT:
------------------

SESSION LIFECYCLE:
1. SESSION CREATION:
   - Generate cryptographically secure token (32 bytes = 64 hex chars)
   - Create UserSession object with metadata
   - Set expiration time (default: 8 hours)
   - Store in memory (never persistent storage)

2. SESSION VALIDATION:
   - Check token exists in active sessions
   - Verify expiration time
   - Update last activity timestamp
   - Return session object or raise exception

3. SESSION EXPIRATION:
   - Automatic timeout after inactivity
   - Background cleanup thread removes expired sessions
   - Explicit logout destroys session immediately
   - Clear sensitive data from memory

SESSION SECURITY FEATURES:
- Tokens are cryptographically random (not predictable)
- Sessions stored only in memory (not disk)
- Automatic cleanup of expired sessions
- Session isolation (users can't access other sessions)
- Concurrent session limits per user
- Activity tracking for security monitoring

USER SESSION CLASS:
------------------

DATACLASS STRUCTURE:
```python
@dataclass
class UserSession:
    session_id: str                    # Unique session identifier
    user_id: int                       # Database user ID
    username: str                      # Username for display
    created_at: datetime               # Session creation time
    last_activity: datetime            # Last activity for timeout
    expires_at: datetime               # Session expiration time
    master_password_hash: str          # Cached password hash
    is_admin: bool                     # Administrative privileges
    login_ip: str                      # IP address for logging
    user_agent: str                    # User agent for logging
    activity_count: int                # Operations counter
    encryption_system: PasswordEncryption  # User's encryption instance
```

KEY METHODS:
- is_expired(): Check if session has expired
- is_active(): Check if session is active and valid
- update_activity(): Update activity timestamp and counter
- extend_session(): Extend expiration time
- time_until_expiry(): Get remaining session time

SECURITY CONSIDERATIONS:
- master_password_hash is not displayed in logs (repr=False)
- Sensitive fields cleared on session destruction
- Activity tracking for security monitoring
- Automatic expiration management

AUTHENTICATION MANAGER:
----------------------

INITIALIZATION:
- Creates DatabaseManager instance for user data
- Initializes session storage (in-memory dictionary)
- Configures security parameters (timeouts, limits)
- Starts background cleanup thread
- Sets up thread synchronization locks

KEY METHODS:

1. CREATE_USER_ACCOUNT:
   - Validates username and password requirements
   - Calls DatabaseManager.create_user()
   - Handles duplicate username errors
   - Logs account creation events

2. AUTHENTICATE_USER:
   - Validates credentials with DatabaseManager
   - Checks for account lockout status
   - Enforces concurrent session limits
   - Generates secure session token
   - Creates and stores UserSession object
   - Returns session token for client use

3. VALIDATE_SESSION:
   - Looks up session by token
   - Checks expiration status
   - Updates activity timestamp
   - Returns session object or raises exception

4. LOGOUT_USER:
   - Removes session from active sessions
   - Clears sensitive session data
   - Logs logout event
   - Returns success status

5. CHANGE_MASTER_PASSWORD:
   - Validates current password
   - Retrieves all encrypted password entries
   - Re-encrypts all passwords with new master password
   - Updates database with new encrypted data
   - Updates session cache
   - Comprehensive error handling

SECURITY FEATURES:
-----------------

SESSION TOKEN SECURITY:
- Uses secrets.token_hex() for cryptographic randomness
- 32-byte tokens (64 hex characters) provide 256-bit entropy
- Tokens are unpredictable and non-sequential
- No timestamp or user information embedded in tokens

CONCURRENT SESSION MANAGEMENT:
- Maximum sessions per user (default: 3)
- Prevents resource exhaustion attacks
- Allows multiple device access while limiting abuse
- Oldest sessions can be evicted if needed

ACCOUNT LOCKOUT INTEGRATION:
- Leverages DatabaseManager lockout functionality
- Failed authentication attempts tracked in database
- Automatic account locking after threshold reached
- Time-based unlock mechanism

MEMORY SECURITY:
- Sessions stored only in RAM (never disk)
- Sensitive data cleared on logout/expiration
- Master password hashes cleared from memory
- Background cleanup prevents memory leaks

ACTIVITY MONITORING:
- Tracks login events with IP and user agent
- Activity counters for usage statistics
- Last activity timestamps for timeout calculation
- Security event logging for audit trails

BACKGROUND CLEANUP:
------------------

CLEANUP THREAD:
- Daemon thread runs every 5 minutes (configurable)
- Scans for expired sessions
- Removes expired sessions from memory
- Clears sensitive data from removed sessions
- Logs cleanup activities

CLEANUP ALGORITHM:
1. Acquire thread lock for session access
2. Iterate through all active sessions
3. Check expiration status for each session
4. Collect list of expired session IDs
5. Remove expired sessions from dictionary
6. Clear sensitive data from removed sessions
7. Release lock and log cleanup results

SHUTDOWN HANDLING:
- Graceful shutdown with cleanup thread termination
- All active sessions cleared from memory
- Database connections properly closed
- Thread synchronization cleanup

PASSWORD OPERATIONS:
-------------------

DESIGN CHALLENGE - MASTER PASSWORD HANDLING:
The authentication system faces a security dilemma:
- Need master password for encryption/decryption operations
- Cannot store master password in memory for security
- Database operations require encrypted password storage/retrieval

CURRENT APPROACH:
- Sessions cache a hash of master password for validation
- Actual encryption/decryption operations require master password
- Methods like decrypt_password_entry() require design modification
- Trade-off between security and usability

POTENTIAL SOLUTIONS:
1. Temporary password caching with strict timeouts
2. Per-operation password prompts for maximum security
3. Derived key caching with periodic re-derivation
4. Hardware security module integration

PASSWORD STRENGTH VALIDATION:
- Comprehensive password strength analysis
- Length, character diversity, pattern detection
- Scoring algorithm with recommendations
- Integration with user account creation
- Helps users create secure master passwords

ERROR HANDLING:
--------------

EXCEPTION HIERARCHY:
- AuthenticationError: Base authentication exception
- SessionExpiredError: Session timeout conditions
- InvalidSessionError: Invalid or missing sessions
- InsufficientPrivilegesError: Authorization failures

ERROR SCENARIOS:
1. Authentication Failures:
   - Invalid credentials
   - Account locked out
   - Too many concurrent sessions
   - Database connectivity issues

2. Session Management Failures:
   - Expired session access
   - Invalid session tokens
   - Session validation errors
   - Memory allocation failures

3. Password Operation Failures:
   - Master password change failures
   - Encryption/decryption errors
   - Database update failures
   - Data corruption issues

LOGGING STRATEGY:
- Security events logged at INFO level
- Errors logged with full context
- Sensitive data never included in logs
- Session IDs truncated for security
- Activity tracking for audit trails

CONFIGURATION OPTIONS:
---------------------

SECURITY PARAMETERS:
- DEFAULT_SESSION_TIMEOUT_HOURS: 8 hours
- MAX_SESSIONS_PER_USER: 3 concurrent sessions
- CLEANUP_INTERVAL_SECONDS: 300 seconds (5 minutes)
- SESSION_TOKEN_LENGTH: 32 bytes (64 hex chars)

CUSTOMIZATION OPTIONS:
- Configurable session timeouts
- Adjustable concurrent session limits
- Variable cleanup intervals
- Custom database paths
- Logging level configuration

PERFORMANCE CONSIDERATIONS:
- In-memory session storage for fast access
- Thread synchronization overhead minimal
- Background cleanup prevents memory growth
- Database operations batched where possible

THREAD SAFETY:
--------------

SYNCHRONIZATION STRATEGY:
- threading.Lock protects session dictionary
- Context managers ensure proper lock handling
- Background thread coordinates with main thread
- Shutdown synchronization prevents race conditions

THREAD-SAFE OPERATIONS:
- Session creation and destruction
- Session validation and updates
- Background cleanup operations
- Shutdown and cleanup procedures

POTENTIAL RACE CONDITIONS:
- Concurrent session access during cleanup
- Multiple authentication attempts
- Session expiration during operations
- Shutdown during active operations

USAGE EXAMPLES:
--------------

BASIC AUTHENTICATION FLOW:
```python
# Initialize authentication manager
auth_manager = AuthenticationManager()

# Create user account
user_id = auth_manager.create_user_account("username", "password")

# Authenticate and get session
session_id = auth_manager.authenticate_user("username", "password")

# Validate session for operations
session = auth_manager.validate_session(session_id)

# Extend session if needed
auth_manager.extend_session(session_id, hours=4)

# Logout when done
auth_manager.logout_user(session_id)

# Shutdown when application closes
auth_manager.shutdown()
```

ERROR HANDLING EXAMPLE:
```python
try:
    session = auth_manager.validate_session(session_id)
except SessionExpiredError:
    # Redirect to login
    return redirect_to_login()
except InvalidSessionError:
    # Invalid session token
    return authentication_error()
```

BEST PRACTICES:
--------------

FOR DEVELOPERS:
1. Always validate sessions before operations
2. Handle session expiration gracefully
3. Clear sensitive data from memory
4. Use proper exception handling
5. Log security events appropriately
6. Test concurrent access scenarios
7. Implement proper shutdown procedures

FOR SECURITY:
1. Use strong master passwords
2. Don't share session tokens
3. Implement proper logout procedures
4. Monitor for suspicious activity
5. Regular security audits
6. Keep session timeouts reasonable
7. Use HTTPS for web interfaces

FUTURE ENHANCEMENTS:
-------------------

PLANNED IMPROVEMENTS:
1. Hardware security module integration
2. Multi-factor authentication support
3. OAuth/SAML integration
4. Session persistence options
5. Advanced activity monitoring
6. Geo-location based security
7. Biometric authentication
8. Zero-knowledge authentication

SCALABILITY CONSIDERATIONS:
- Redis session storage for multi-instance deployment
- Database connection pooling
- Load balancing session management
- Distributed session cleanup
- Horizontal scaling support

This authentication system provides a secure foundation for the password manager
with enterprise-level session management, comprehensive security features, and
robust error handling suitable for both desktop and web interfaces.