ENCRYPTION SYSTEM - DETAILED CODE EXPLANATION
============================================

This document provides a comprehensive explanation of the encryption system implementation
for the Personal Password Manager, covering cryptographic algorithms, security measures,
and implementation details.

OVERVIEW:
---------
The encryption system (src/core/encryption.py) implements military-grade AES-256 encryption
with PBKDF2 key derivation to securely protect user passwords. It follows industry best
practices and cryptographic standards to ensure maximum security.

CRYPTOGRAPHIC ALGORITHMS:
------------------------

1. AES-256-CBC ENCRYPTION:
   - Algorithm: Advanced Encryption Standard
   - Key Size: 256 bits (quantum-resistant)
   - Mode: Cipher Block Chaining (CBC)
   - Block Size: 128 bits (16 bytes)
   - Padding: PKCS7 for proper block alignment

2. PBKDF2-HMAC-SHA256 KEY DERIVATION:
   - Algorithm: Password-Based Key Derivation Function 2
   - Hash: SHA-256 (256-bit output)
   - Iterations: 100,000+ (configurable, OWASP recommended)
   - Salt Length: 32 bytes (256 bits)
   - Output: 32-byte encryption key

3. CRYPTOGRAPHICALLY SECURE RANDOM GENERATION:
   - Source: Operating system entropy (/dev/urandom on Unix, CryptGenRandom on Windows)
   - Used for: Salt generation, IV generation
   - Quality: Cryptographically secure pseudorandom number generator (CSPRNG)

SECURITY DESIGN PRINCIPLES:
--------------------------

1. DEFENSE IN DEPTH:
   - Multiple layers of security (encryption + hashing + salting)
   - Each password gets unique salt and IV
   - Master password never stored in plain text
   - Derived keys never reused

2. FORWARD SECRECY:
   - Unique salt per password ensures different keys
   - IV randomization prevents pattern analysis
   - Key derivation parameters can be upgraded

3. RESISTANCE TO ATTACKS:
   - Rainbow Tables: Unique salts prevent precomputed attacks
   - Brute Force: High iteration count increases computation cost
   - Timing Attacks: Constant-time operations where possible
   - Side Channel: Memory clearing attempts

4. FUTURE-PROOFING:
   - Version field allows algorithm upgrades
   - Configurable iteration counts
   - Modular design for easy updates

ENCRYPTION PROCESS FLOW:
-----------------------

ENCRYPTION (plaintext → ciphertext):
1. Input Validation:
   - Check plaintext password is not empty
   - Validate master password is provided
   - Ensure parameters are correct types

2. Random Generation:
   - Generate 32-byte cryptographic salt
   - Generate 16-byte initialization vector (IV)
   - Use OS entropy source for maximum security

3. Key Derivation:
   - Combine master password with salt
   - Apply PBKDF2-HMAC-SHA256 with configured iterations
   - Produce 32-byte AES key
   - Clear master password from memory

4. Plaintext Preparation:
   - Convert password string to UTF-8 bytes
   - Apply PKCS7 padding to match AES block size
   - Ensure data is properly aligned

5. AES Encryption:
   - Create AES-256 cipher in CBC mode
   - Use derived key and generated IV
   - Encrypt padded plaintext
   - Combine all components

6. Storage Format Assembly:
   Format: VERSION(1) + SALT(32) + IV(16) + CIPHERTEXT(variable)
   - VERSION: Format version for future compatibility
   - SALT: Unique salt used for key derivation
   - IV: Initialization vector for AES-CBC
   - CIPHERTEXT: Encrypted password data

7. Memory Cleanup:
   - Clear derived key from memory
   - Clear plaintext bytes from memory
   - Clear padded data from memory

DECRYPTION PROCESS FLOW:
-----------------------

DECRYPTION (ciphertext → plaintext):
1. Input Validation:
   - Check encrypted blob is not empty
   - Validate master password is provided
   - Ensure blob meets minimum size requirements

2. Blob Parsing:
   - Extract version byte and validate
   - Extract 32-byte salt
   - Extract 16-byte IV
   - Extract remaining ciphertext
   - Validate ciphertext length is multiple of block size

3. Key Derivation:
   - Use extracted salt with master password
   - Apply same PBKDF2 parameters as encryption
   - Produce identical 32-byte AES key
   - Clear master password from memory

4. AES Decryption:
   - Create AES-256 cipher in CBC mode
   - Use derived key and extracted IV
   - Decrypt ciphertext to padded plaintext

5. Plaintext Recovery:
   - Remove PKCS7 padding
   - Convert bytes back to UTF-8 string
   - Validate resulting string is valid

6. Memory Cleanup:
   - Clear derived key from memory
   - Clear padded plaintext from memory
   - Clear plaintext bytes from memory

ERROR HANDLING HIERARCHY:
------------------------

EXCEPTION CLASSES:
- EncryptionError: General encryption failures
- DecryptionError: General decryption failures  
- InvalidKeyError: Key derivation or validation issues
- CorruptedDataError: Data integrity or format problems

ERROR SCENARIOS:
1. Encryption Failures:
   - Empty plaintext or master password
   - Salt/IV generation failures
   - Key derivation failures
   - AES encryption failures
   - Memory allocation failures

2. Decryption Failures:
   - Empty blob or master password
   - Corrupted or truncated data
   - Unsupported version formats
   - Invalid ciphertext length
   - Incorrect master password
   - Padding removal failures
   - UTF-8 decoding failures

STORAGE FORMAT SPECIFICATION:
----------------------------

ENCRYPTED BLOB STRUCTURE:
Offset | Length | Field       | Description
-------|--------|-------------|------------------------------------
0      | 1      | VERSION     | Format version (currently 0x01)
1      | 32     | SALT        | PBKDF2 salt for key derivation
33     | 16     | IV          | AES initialization vector
49     | N      | CIPHERTEXT  | AES-256-CBC encrypted data

PROPERTIES:
- Total minimum size: 49 bytes + ciphertext
- Ciphertext size: Multiple of 16 bytes (AES block size)
- Maximum supported size: Limited by available memory
- Endianness: Network byte order for multi-platform compatibility

VERSION MANAGEMENT:
- Version 0x01: Current format (AES-256-CBC + PBKDF2-SHA256)
- Future versions can add new algorithms or parameters
- Backward compatibility maintained through version detection

SECURITY PARAMETERS:
-------------------

PBKDF2 CONFIGURATION:
- Default Iterations: 100,000 (OWASP minimum recommendation)
- Minimum Secure: 10,000 iterations
- High Security: 500,000+ iterations
- Performance Impact: ~100ms per operation on modern hardware

SALT PROPERTIES:
- Length: 32 bytes (256 bits)
- Source: Cryptographically secure random generator
- Uniqueness: Every encryption gets new salt
- Storage: Included in encrypted blob

IV PROPERTIES:
- Length: 16 bytes (128 bits, one AES block)
- Source: Cryptographically secure random generator
- Uniqueness: Every encryption gets new IV
- Reuse Policy: Never reused with same key

KEY PROPERTIES:
- Length: 32 bytes (256 bits)
- Derivation: PBKDF2-HMAC-SHA256
- Lifetime: Single encryption/decryption operation
- Storage: Never stored, derived on demand

PERFORMANCE CONSIDERATIONS:
--------------------------

COMPUTATIONAL COSTS:
1. Key Derivation: Dominant cost (intentionally expensive)
   - 100,000 iterations ≈ 100ms on modern CPU
   - Scales linearly with iteration count
   - Memory usage: Minimal (streaming hash)

2. AES Operations: Minimal cost
   - Hardware acceleration available on modern CPUs
   - <1ms for typical password lengths
   - Memory usage: Small fixed overhead

3. Random Generation: Negligible cost
   - OS entropy pool access
   - <1ms for salt and IV generation

OPTIMIZATION STRATEGIES:
- Configurable iteration counts for different security levels
- Hardware AES acceleration when available
- Memory pre-allocation for large operations
- Batch processing for multiple passwords

MEMORY SECURITY:
---------------

SENSITIVE DATA HANDLING:
1. Master Passwords:
   - Converted to bytes immediately
   - Cleared from memory after key derivation
   - Never stored permanently

2. Derived Keys:
   - Used immediately for encryption/decryption
   - Cleared from memory after use
   - Never logged or stored

3. Plaintext Passwords:
   - Minimized lifetime in memory
   - Cleared after encryption
   - Avoided in intermediate variables

MEMORY CLEARING LIMITATIONS:
- Python's garbage collection may retain copies
- String interning can prevent clearing
- OS virtual memory may swap to disk
- Hardware optimizations may cache data

BEST EFFORT APPROACHES:
- Overwrite variables with zeros
- Use bytes instead of strings when possible
- Minimize plaintext lifetime
- Clear variables explicitly

CRYPTOGRAPHIC VALIDATION:
------------------------

ALGORITHM SELECTION RATIONALE:
1. AES-256: NSA Suite B approved, quantum-resistant
2. CBC Mode: Well-tested, suitable for password storage
3. PBKDF2: NIST approved, widely supported
4. SHA-256: Secure hash function, good performance

SECURITY ANALYSIS:
- Key Space: 2^256 (practically unbreakable)
- Quantum Resistance: AES-256 provides ~128-bit post-quantum security
- Side Channel Resistance: Constant-time operations where possible
- Implementation: Uses vetted cryptographic libraries

COMPLIANCE:
- OWASP Password Storage Guidelines
- NIST SP 800-132 (PBKDF2 recommendations)
- FIPS 140-2 Level 1 (algorithms)

USAGE EXAMPLES:
--------------

BASIC ENCRYPTION:
```python
# Initialize encryption system
encryption = PasswordEncryption()

# Encrypt a password
encrypted_blob = encryption.encrypt_password("mypassword", "master123")

# Decrypt the password
decrypted = encryption.decrypt_password(encrypted_blob, "master123")
```

MASTER PASSWORD CHANGE:
```python
# Change master password
new_blob = encryption.change_master_password(
    encrypted_blob, "old_master", "new_master"
)
```

PERFORMANCE TUNING:
```python
# Custom iteration count for faster operations
fast_encryption = PasswordEncryption(pbkdf2_iterations=50000)

# Benchmark different iteration counts
results = benchmark_encryption_performance()
```

SECURITY VERIFICATION:
```python
# Verify master password without decrypting
is_valid = encryption.verify_master_password(encrypted_blob, "master123")

# Get encryption metadata
info = encryption.get_encryption_info(encrypted_blob)
```

BEST PRACTICES:
--------------

FOR DEVELOPERS:
1. Never log or print plaintext passwords or keys
2. Use secure memory clearing functions
3. Handle exceptions properly to prevent data leakage
4. Validate all inputs before processing
5. Use appropriate iteration counts for security level
6. Test with various password lengths and characters
7. Implement proper key rotation procedures

FOR USERS:
1. Use strong master passwords (12+ characters)
2. Don't reuse master passwords elsewhere
3. Regularly backup encrypted database
4. Keep software updated for security patches
5. Use appropriate iteration counts for hardware
6. Monitor for failed decryption attempts

FUTURE ENHANCEMENTS:
-------------------

PLANNED IMPROVEMENTS:
1. Hardware Security Module (HSM) support
2. Additional encryption algorithms (ChaCha20, AES-GCM)
3. Key stretching with Argon2 or scrypt
4. Authenticated encryption modes
5. Post-quantum cryptography preparation
6. Hardware acceleration optimization
7. Secure enclave integration
8. Zero-knowledge proof systems

MIGRATION STRATEGY:
- Version field allows seamless upgrades
- Gradual migration during password updates
- Backward compatibility maintenance
- User notification of available upgrades

This encryption system provides enterprise-grade security suitable for protecting
sensitive password data while maintaining reasonable performance and usability.